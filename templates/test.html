<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Test</title>

    <!-- jQuery -->
    <script src="{{ url_for('static', filename='js/jquery.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/proxyMapper.js') }}"></script>
    <script src="{{ url_for('static', filename='js/treeFromJson.js') }}"></script>
    <script src="{{ url_for('static', filename='js/d3.js') }}"></script>
    <script src="http://d3js.org/d3.v3.min.js"></script>

    <!-- TEMP -->
    <link href="{{ url_for('static', filename='css/bootstrap.min.css') }}" rel="stylesheet">
    <script src="{{ url_for('static', filename='js/bootstrap.js') }}"></script>
    <link href="{{ url_for('static', filename='css/font-awesome.min.css') }}" rel="stylesheet">

<style>
    .resultTree {
        float:  right;
    }
    .node {
        cursor: pointer;
    }
    .node.nodeNoInteraction {
        cursor: default;
    }
    .node circle {
        fill: #fff;
        stroke: steelblue;
        stroke-width: 3px;
    }
    .node text {
        font: 12px sans-serif;
    }
    .link {
        fill: none;
        stroke: #ccc;
        stroke-width: 2px;
    }

    .mappingTable {
        display: inline-table !important;
        cursor: pointer;
        width: 50%;
    }

    .mappingTableDivConfig {
        display: inline-block;
        position: absolute;
        margin-left: 10px;
        margin-top: 10px;
    }


    .mappingTable td {
        height: 37px;
        font-size: medium;
        border-left: 1px solid #ddd;
    }

    td.grey {
        background-color: grey !important;
    }

    .linkText {
        font-size: 18px;
        fill: #000;
    }
    .rectText {
        fill: #fff;
    }
</style>


</head>

<body>

    <div id='treediv'></div>

    <script>
        //function isObject(v) {
        //    return v !== null && typeof v === 'object';
        //}

        //function create_tree(root, depth, maxDepth, maxWidth) {
        //    if (depth == 0) {
        //        return;
        //    }
        //    var child = {
        //        parent: null
        //    };

        //    if (Array.isArray(root)) {
        //        child.children = [];

        //        for (var node of root.slice(0, maxWidth)) {
        //            child['children'].push(create_tree(node, depth-1, maxDepth, maxWidth));
        //        }
        //        if (root.length > maxWidth) {
        //            var addNode = {};
        //            addNode.name = '...';
        //            addNode.parent = null;
        //            addNode.additionalNode = true;
        //            child['children'].push(addNode);
        //        }
        //        return child;

        //    } else if (isObject(root)) {
        //        child.children = {};

        //        for (var k in root.slice(0, maxWidth)) {
        //            var node = root[k];
        //            child['children'] = create_tree(node, depth-1, maxDepth, maxWidth);
        //        }
        //        if (root.length > maxWidth) {
        //            var addNode = {};
        //            addNode.name = '...';
        //            addNode.parent = null;
        //            addNode.additionalNode = true;
        //            child['children'].push(addNode);
        //        }
        //        return child;

        //    } else {
        //        child.name = root;
        //        return child;
        //    }

        //}
    </script>

    <script>
        //var mapping = {
        //    dates: ['p', 0],
        //    labels: ['d', 1, 'p', 0],
        //    values: [1],
        //    dateFromNode: [0],
        //};
        //
        //var res;
        //$.getJSON('{{ url_for("testData") }}', function(data) {
        //    console.log(data);
        //    res = new $.proxyMapper(mapping, data, {});
        //    console.log(res);
        //});


        var pickingList = ['dates', 'labels', 'values'];

        var endpoint = [];
        var tfj;
        $.getJSON('{{ url_for("testData") }}', function(data) {
            var depth = 5;
            var width = 3;

            var options = {
                toBeMapped: pickingList,
            };
            tfj = $('#treediv').treeFromJson(data, options);
        });



//function create_mapping_table(pickingList) {
//    var table = $('<table style="width: 400px;"></table>');
//    var thead = $('<thead></thead>')
//    var tbody = $('<thead></thead>')
//    var row1 = $('<tr></tr>');
//    var row2 = $('<tr style="height: 20px;"></tr>');
//    for (var entry of pickingList) {
//        row1.append($('<th>'+entry+'</th>'));
//        row2.append($('<td id="'+entry+'Cell"></td>'));
//    }
//    thead.append(row1);
//    tbody.append(row2);
//    table.append(thead);
//    table.append(tbody);
//    $('#mappingdiv').append(table);
//}

    </script>


    <script>
//var treeData = [
//    {
//        "name": "Top Level",
//        "parent": "null",
//        "children": [
//            {
//                "name": "Level 2: A",
//                "parent": "Top Level",
//                "children": [
//                    {
//                        "name": "Son of A",
//                        "parent": "Level 2: A"
//                    },
//                    {
//                        "name": "Daughter of A",
//                        "parent": "Level 2: A"
//                    }
//                ]
//            },
//            {
//                "name": "Level 2: B",
//                "parent": "Top Level"
//            }
//        ]
//    }
//];
//
//
//
//// ************** Generate the tree diagram  *****************
//var margin = {top: 20, right: 120, bottom: 20, left: 120},
//        width = 960 - margin.right - margin.left,
//        height = 500 - margin.top - margin.bottom;
//    
//var i = 0,
//    duration = 750,
//    root;
//
//var tree = d3.layout.tree()
//        .size([height, width]);
//
//var diagonal = d3.svg.diagonal()
//        .projection(function(d) { return [d.y, d.x]; });
//
//var svg = d3.select("#treediv").append("svg")
//        .attr("width", width + margin.right + margin.left)
//        .attr("height", height + margin.top + margin.bottom)
//    .append("g")
//        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
//
//root = treeData[0];
////root = endpoint[0];
//root.x0 = height / 2;
//root.y0 = 0;
//  
//update(root);
//
//d3.select(self.frameElement).style("height", "500px");
//
//function update(source) {
//
//    // Compute the new tree layout.
//    var nodes = tree.nodes(root).reverse(),
//        links = tree.links(nodes);
//
//    // Normalize for fixed-depth.
//    nodes.forEach(function(d) { d.y = d.depth * 180; });
//
//    // Update the nodesâ€¦
//    var node = svg.selectAll("g.node")
//            .data(nodes, function(d) { return d.id || (d.id = ++i); });
//
//    // Enter any new nodes at the parent's previous position.
//    var nodeEnter = node.enter().append("g")
//        .attr("class", "node")
//        .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
//        .on("click", click);
//
//    nodeEnter.append("circle")
//        .attr("r", 1e-6)
//        .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
//
//    nodeEnter.append("text")
//        .attr("x", function(d) { return d.children || d._children ? -13 : 13; })
//        .attr("dy", ".35em")
//        .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
//        .text(function(d) { return d.name; })
//        .style("fill-opacity", 1e-6);
//
//
//    // Transition nodes to their new position.
//    var nodeUpdate = node.transition()
//        .duration(duration)
//        .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });
//
//    nodeUpdate.select("circle")
//        .attr("r", 10)
//        .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });
//
//    nodeUpdate.select("text")
//        .style("fill-opacity", 1);
//
//    // Transition exiting nodes to the parent's new position.
//    var nodeExit = node.exit().transition()
//        .duration(duration)
//        .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
//        .remove();
//
//    nodeExit.select("circle")
//        .attr("r", 1e-6);
//
//    nodeExit.select("text")
//        .style("fill-opacity", 1e-6);
//
//    // Update the links...
//    var link = svg.selectAll("path.link")
//        .data(links, function(d) { return d.target.id; });
//
//    // Enter any new links at the parent's previous position.
//    link.enter().insert("path", "g")
//        .attr("class", "link")
//        .attr("d", function(d) {
//            var o = {x: source.x0, y: source.y0};
//            return diagonal({source: o, target: o});
//        });
//
//    // Transition links to their new position.
//    link.transition()
//        .duration(duration)
//        .attr("d", diagonal);
//
//    // Transition exiting nodes to the parent's new position.
//    link.exit().transition()
//        .duration(duration)
//        .attr("d", function(d) {
//            var o = {x: source.x, y: source.y};
//            return diagonal({source: o, target: o});
//        })
//        .remove();
//
//    // Stash the old positions for transition.
//    nodes.forEach(function(d) {
//        d.x0 = d.x;
//        d.y0 = d.y;
//    });
//}
//
//// Toggle children on click.
//function click(d) {
//    if (d.children) {
//        d._children = d.children;
//        d.children = null;
//    } else {
//        d.children = d._children;
//        d._children = null;
//    }
//    update(d);
//}

    </script>

</body>

</html>
